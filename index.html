<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OpenCircuit</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        color-scheme: dark;
        user-select: none;
        font-family: 'JetBrains Mono', monospace;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      canvas {
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        top: 15px;
        left: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px;
        border: 1px solid #333;
        border-radius: 6px;
        backdrop-filter: blur(8px);
        width: 140px;
        z-index: 10;
        max-height: 80vh;
        overflow-y: auto;
      }

      .hud::-webkit-scrollbar {
        width: 4px;
      }
      .hud::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }
      .hud::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 2px;
      }

      button {
        padding: 10px;
        background: #000;
        border: 1px solid #333;
        border-radius: 4px;
        color: #ccc;
        cursor: pointer;
        font-size: 12px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.1s;
        flex-shrink: 0;
      }

      button:hover {
        background: #252525;
        border-color: #444;
        color: #fff;
      }
      button:active {
        background: #333;
      }
      button.danger {
        border-color: #522;
        color: #e55;
      }
      button.danger:hover {
        background: #311;
      }

      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div class="hud" id="hud"></div>

    <script>
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')
      const hud = document.getElementById('hud')

      const GRID_SIZE = 25

      const TOOLS = {
        WIRE: { label: 'WIRE', color: '#888', w: 1, h: 1, ins: 0, outs: 0 },
        INPUT: { label: 'IN', color: '#3b82f6', w: 2, h: 2, ins: 0, outs: 1 },
        OUTPUT: { label: 'OUT', color: '#22c55e', w: 2, h: 2, ins: 1, outs: 0 },
        NOT: { label: 'NOT', color: '#ef4444', w: 2, h: 2, ins: 1, outs: 1 },
        AND: { label: 'AND', color: '#eab308', w: 2, h: 2, ins: 2, outs: 1 },
        NAND: { label: 'NAND', color: '#14b8a6', w: 2, h: 2, ins: 2, outs: 1 },
        OR: { label: 'OR', color: '#a855f7', w: 2, h: 2, ins: 2, outs: 1 },
        NOR: { label: 'NOR', color: '#f97316', w: 2, h: 2, ins: 2, outs: 1 },
        XOR: { label: 'XOR', color: '#ec4899', w: 2, h: 2, ins: 2, outs: 1 },
        XNOR: { label: 'XNOR', color: '#6366f1', w: 2, h: 2, ins: 2, outs: 1 },
      }

      let components = []
      let wires = new Map()
      let wireStates = new Map()

      let camera = { x: 0, y: 0 }
      let mode = 'IDLE'
      let dragStart = { x: 0, y: 0 }
      let newCompType = null
      let draggingComp = null
      let draggingWire = null
      let dragOffset = { x: 0, y: 0 }
      let initialPos = { x: 0, y: 0 }
      let mouseGrid = { x: 0, y: 0 }

      class Component {
        constructor(gx, gy, type) {
          this.gx = gx
          this.gy = gy
          this.type = type
          this.id = Math.random().toString(36).substr(2, 9)
          this.state = false
          this.isLit = false
        }
      }

      function simulate() {
        let currentState = new Map()
        let queue = []
        let visited = new Set()

        components.forEach((c) => {
          const def = TOOLS[c.type]
          let isActive = false

          if (c.type === 'INPUT') {
            isActive = c.state
          } else if (c.type !== 'WIRE') {
            const in1 = currentState.get(`${c.gx - 1},${c.gy}`) || false
            const in2 = currentState.get(`${c.gx - 1},${c.gy + 1}`) || false

            if (c.type === 'OUTPUT') {
              c.isLit = in1
              return
            }

            if (c.type === 'NOT') isActive = !in1
            if (c.type === 'AND') isActive = in1 && in2
            if (c.type === 'NAND') isActive = !(in1 && in2)
            if (c.type === 'OR') isActive = in1 || in2
            if (c.type === 'NOR') isActive = !(in1 || in2)
            if (c.type === 'XOR') isActive = !!in1 !== !!in2
            if (c.type === 'XNOR') isActive = !!in1 === !!in2
          }

          if (isActive) {
            const outX = c.gx + def.w
            const outY = c.gy
            const key = `${outX},${outY}`
            if (!currentState.has(key)) {
              currentState.set(key, true)
              queue.push({ x: outX, y: outY })
            }
          }
        })

        while (queue.length > 0) {
          const curr = queue.shift()
          const key = `${curr.x},${curr.y}`

          if (visited.has(key)) continue
          visited.add(key)

          const neighbors = [
            { x: curr.x + 1, y: curr.y },
            { x: curr.x - 1, y: curr.y },
            { x: curr.x, y: curr.y + 1 },
            { x: curr.x, y: curr.y - 1 },
          ]

          neighbors.forEach((n) => {
            const nKey = `${n.x},${n.y}`
            if (isConductive(n.x, n.y)) {
              if (!currentState.has(nKey)) {
                currentState.set(nKey, true)
                queue.push(n)
              }
            }
          })
        }

        components.forEach((c) => {
          if (c.type === 'OUTPUT') {
            c.isLit = currentState.get(`${c.gx - 1},${c.gy}`) || false
          }
        })

        wireStates = currentState
      }

      function isConductive(gx, gy) {
        if (wires.has(`${gx},${gy}`)) return true
        return components.some((c) => {
          const def = TOOLS[c.type]
          if (def.ins >= 1 && gx === c.gx - 1 && gy === c.gy) return true
          if (def.ins >= 2 && gx === c.gx - 1 && gy === c.gy + 1) return true
          if (def.outs >= 1 && gx === c.gx + def.w && gy === c.gy) return true
          return false
        })
      }

      function shouldConnect(x1, y1, x2, y2) {
        const hasWire1 = wires.has(`${x1},${y1}`)
        const hasWire2 = wires.has(`${x2},${y2}`)

        if (x1 === x2 && y1 === y2) return true

        // TBD Because it looks weird sometimes
        if (!hasWire1 && !hasWire2) return false

        return isConductive(x1, y1) && isConductive(x2, y2)
      }

      function checkCollision(gx, gy, type, excludeId = null) {
        const def = TOOLS[type]

        const bodyCollision = components.some((c) => {
          if (c.id === excludeId) return false
          const cDef = TOOLS[c.type]
          return (
            gx < c.gx + cDef.w &&
            gx + def.w > c.gx &&
            gy < c.gy + cDef.h &&
            gy + def.h > c.gy
          )
        })
        if (bodyCollision) return true

        if (type !== 'WIRE') {
          if (def.ins > 0) {
            if (isBodyAt(gx - 1, gy, excludeId)) return true
            if (def.ins > 1 && isBodyAt(gx - 1, gy + 1, excludeId)) return true
          }
          if (def.outs > 0) {
            if (isBodyAt(gx + def.w, gy, excludeId)) return true
          }
          const myRect = { x: gx, y: gy, w: def.w, h: def.h }
          const pinCollision = components.some((c) => {
            if (c.id === excludeId) return false
            const cDef = TOOLS[c.type]
            if (cDef.outs > 0 && pointInRect(c.gx + cDef.w, c.gy, myRect))
              return true
            if (cDef.ins > 0) {
              if (pointInRect(c.gx - 1, c.gy, myRect)) return true
              if (cDef.ins > 1 && pointInRect(c.gx - 1, c.gy + 1, myRect))
                return true
            }
            return false
          })
          if (pinCollision) return true

          for (let x = gx; x < gx + def.w; x++) {
            for (let y = gy; y < gy + def.h; y++) {
              if (wires.has(`${x},${y}`)) return true
            }
          }
        }
        return false
      }

      function isBodyAt(x, y, excludeId) {
        return components.some((c) => {
          if (c.id === excludeId) return false
          const def = TOOLS[c.type]
          return x >= c.gx && x < c.gx + def.w && y >= c.gy && y < c.gy + def.h
        })
      }

      function pointInRect(px, py, rect) {
        return (
          px >= rect.x &&
          px < rect.x + rect.w &&
          py >= rect.y &&
          py < rect.y + rect.h
        )
      }

      function drawGrid() {
        ctx.strokeStyle = '#1a1a1a'
        ctx.lineWidth = 1
        ctx.beginPath()
        const offX = camera.x % GRID_SIZE
        const offY = camera.y % GRID_SIZE
        for (let x = offX; x < canvas.width; x += GRID_SIZE) {
          ctx.moveTo(x + 0.5, 0)
          ctx.lineTo(x + 0.5, canvas.height)
        }
        for (let y = offY; y < canvas.height; y += GRID_SIZE) {
          ctx.moveTo(0, y + 0.5)
          ctx.lineTo(canvas.width, y + 0.5)
        }
        ctx.stroke()
      }

      function drawWires() {
        ctx.lineCap = 'round'
        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`
        const activeWidth = 2 + pulse * 1.5

        wires.forEach((_, key) => {
          const [gx, gy] = key.split(',').map(Number)
          drawWireSegment(gx, gy, wireStates.get(key), activeColor, activeWidth)
        })
      }

      function drawWireSegment(gx, gy, isPowered, activeColor, activeWidth) {
        const px = gx * GRID_SIZE + camera.x + GRID_SIZE / 2
        const py = gy * GRID_SIZE + camera.y + GRID_SIZE / 2

        ctx.strokeStyle = isPowered ? activeColor : '#555'
        ctx.lineWidth = isPowered ? activeWidth : 2
        ctx.shadowBlur = isPowered ? 8 : 0
        ctx.shadowColor = '#ffffaa'

        const u = shouldConnect(gx, gy, gx, gy - 1)
        const d = shouldConnect(gx, gy, gx, gy + 1)
        const l = shouldConnect(gx, gy, gx - 1, gy)
        const r = shouldConnect(gx, gy, gx + 1, gy)

        ctx.beginPath()
        if (u) {
          ctx.moveTo(px, py)
          ctx.lineTo(px, py - GRID_SIZE / 2)
        }
        if (d) {
          ctx.moveTo(px, py)
          ctx.lineTo(px, py + GRID_SIZE / 2)
        }
        if (l) {
          ctx.moveTo(px, py)
          ctx.lineTo(px - GRID_SIZE / 2, py)
        }
        if (r) {
          ctx.moveTo(px, py)
          ctx.lineTo(px + GRID_SIZE / 2, py)
        }

        if (!u && !d && !l && !r) {
          ctx.moveTo(px - 4, py)
          ctx.lineTo(px + 4, py)
        }

        ctx.stroke()

        const neighbors = (u ? 1 : 0) + (d ? 1 : 0) + (l ? 1 : 0) + (r ? 1 : 0)
        const isStraight = (u && d && !l && !r) || (l && r && !u && !d)

        if (
          neighbors > 2 ||
          (neighbors === 2 && !isStraight) ||
          neighbors === 1
        ) {
          ctx.fillStyle = isPowered ? activeColor : '#555'
          ctx.beginPath()
          ctx.arc(px, py, isPowered ? 4 : 3, 0, Math.PI * 2)
          ctx.fill()
        }
        ctx.shadowBlur = 0
      }

      function drawComponent(c, isGhost = false) {
        if (c.type === 'WIRE') {
          const gx = c.gx
          const gy = c.gy
          drawWireSegment(gx, gy, false, '#fff', 2)
          return
        }

        const def = TOOLS[c.type]
        const x = c.gx * GRID_SIZE + camera.x
        const y = c.gy * GRID_SIZE + camera.y
        const w = def.w * GRID_SIZE
        const h = def.h * GRID_SIZE

        if (isGhost) ctx.globalAlpha = 0.6
        if (isGhost && checkCollision(c.gx, c.gy, c.type))
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'
        else ctx.fillStyle = '#000'

        ctx.save()

        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`
        const activeWidth = 2 + pulse * 1.5

        const drawPin = (pgx, pgy) => {
          const isPowered = wireStates.get(`${pgx},${pgy}`)
          drawWireSegment(pgx, pgy, isPowered, activeColor, activeWidth)
        }

        if (def.ins >= 1) drawPin(c.gx - 1, c.gy)
        if (def.ins >= 2) drawPin(c.gx - 1, c.gy + 1)
        if (def.outs >= 1) drawPin(c.gx + def.w, c.gy)

        ctx.restore()

        ctx.fillRect(x, y, w, h)
        ctx.strokeStyle = def.color
        ctx.lineWidth = 2
        ctx.strokeRect(x, y, w, h)

        ctx.fillStyle = def.color
        ctx.font = 'bold 12px "JetBrains Mono"'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        if (c.type === 'INPUT') {
          const pad = 8
          ctx.fillStyle = '#000'
          ctx.fillRect(x + pad, y + pad, w - pad * 2, h - pad * 2)
          if (c.state) {
            ctx.fillStyle = '#4f4'
            ctx.fillRect(
              x + pad + 2,
              y + pad + 2,
              w - pad * 2 - 4,
              h - pad * 2 - 4
            )
            ctx.fillStyle = '#fff'
            ctx.fillText('ON', x + w / 2, y + h / 2)
          } else {
            ctx.fillStyle = '#333'
            ctx.fillText('OFF', x + w / 2, y + h / 2)
          }
        } else if (c.type === 'OUTPUT') {
          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 12, 0, Math.PI * 2)
          ctx.fillStyle = '#000'
          ctx.fill()

          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 8, 0, Math.PI * 2)
          if (c.isLit) {
            ctx.fillStyle = '#ffff00'
            ctx.shadowColor = '#ffff00'
            ctx.shadowBlur = 20
          } else {
            ctx.fillStyle = '#333'
          }
          ctx.fill()
          ctx.shadowBlur = 0
        } else {
          ctx.fillText(def.label, x + w / 2, y + h / 2)
        }

        if (isGhost) ctx.globalAlpha = 1.0
      }

      function render() {
        simulate()
        ctx.fillStyle = '#0f0f0f'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        drawGrid()
        drawWires()
        for (const c of components) drawComponent(c)
        if (mode === 'DRAGGING_NEW' && newCompType) {
          drawComponent(
            { gx: mouseGrid.x, gy: mouseGrid.y, type: newCompType },
            true
          )
        }
      }

      function getGrid(clientPos) {
        return {
          x: Math.floor((clientPos.x - camera.x) / GRID_SIZE),
          y: Math.floor((clientPos.y - camera.y) / GRID_SIZE),
        }
      }

      function initHUD() {
        Object.keys(TOOLS).forEach((key) => {
          const def = TOOLS[key]
          const btn = document.createElement('button')
          const swatch = document.createElement('span')
          swatch.className = 'swatch'
          swatch.style.backgroundColor = def.color
          btn.appendChild(swatch)
          btn.appendChild(document.createTextNode(def.label))

          btn.onpointerdown = (e) => {
            e.preventDefault()
            e.stopPropagation()
            btn.setPointerCapture(e.pointerId)
            mode = 'DRAGGING_NEW'
            newCompType = key
            mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
          }

          btn.onpointerup = (e) => {
            btn.releasePointerCapture(e.pointerId)
            if (mode === 'DRAGGING_NEW') {
              const g = getGrid({ x: e.clientX, y: e.clientY })
              if (newCompType === 'WIRE') {
                if (!checkCollision(g.x, g.y, 'WIRE'))
                  wires.set(`${g.x},${g.y}`, true)
              } else {
                if (!checkCollision(g.x, g.y, newCompType)) {
                  components.push(new Component(g.x, g.y, newCompType))
                }
              }
            }
            mode = 'IDLE'
            newCompType = null
          }
          hud.appendChild(btn)
        })

        const clearBtn = document.createElement('button')
        clearBtn.className = 'danger'
        clearBtn.innerText = 'Clear All'
        clearBtn.onclick = () => {
          if (confirm('Reset Board?')) {
            components = []
            wires.clear()
            wireStates.clear()
          }
        }
        hud.appendChild(clearBtn)
      }

      canvas.addEventListener('pointerdown', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })

        if (e.button === 2) {
          const hit = components.find(
            (c) =>
              g.x >= c.gx &&
              g.x < c.gx + TOOLS[c.type].w &&
              g.y >= c.gy &&
              g.y < c.gy + TOOLS[c.type].h
          )
          if (hit) components.splice(components.indexOf(hit), 1)
          else {
            wires.delete(`${g.x},${g.y}`)
            mode = 'ERASING'
          }
          return
        }

        const hit = components.find(
          (c) =>
            g.x >= c.gx &&
            g.x < c.gx + TOOLS[c.type].w &&
            g.y >= c.gy &&
            g.y < c.gy + TOOLS[c.type].h
        )

        if (hit) {
          if (hit.type === 'INPUT') {
            const screenX = hit.gx * GRID_SIZE + camera.x
            const screenY = hit.gy * GRID_SIZE + camera.y
            const cx = e.clientX - screenX
            const cy = e.clientY - screenY
            const pad = 8
            const w = TOOLS[hit.type].w * GRID_SIZE
            const h = TOOLS[hit.type].h * GRID_SIZE

            if (cx > pad && cx < w - pad && cy > pad && cy < h - pad) {
              hit.state = !hit.state
            } else {
              mode = 'DRAGGING_EXISTING'
              draggingComp = hit
              initialPos = { gx: hit.gx, gy: hit.gy }
              dragOffset = { x: g.x - hit.gx, y: g.y - hit.gy }
            }
          } else {
            mode = 'DRAGGING_EXISTING'
            draggingComp = hit
            initialPos = { gx: hit.gx, gy: hit.gy }
            dragOffset = { x: g.x - hit.gx, y: g.y - hit.gy }
          }
        } else if (wires.has(`${g.x},${g.y}`)) {
          mode = 'DRAGGING_WIRE'
          draggingWire = `${g.x},${g.y}`
          wires.delete(draggingWire)
        } else {
          mode = 'PANNING'
          dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
        }
      })

      window.addEventListener('pointermove', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })
        mouseGrid = g
        if (mode === 'PANNING') {
          camera.x = e.clientX - dragStart.x
          camera.y = e.clientY - dragStart.y
        } else if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          draggingComp.gx = g.x - dragOffset.x
          draggingComp.gy = g.y - dragOffset.y
        } else if (mode === 'DRAGGING_WIRE') {
        } else if (mode === 'ERASING') {
          wires.delete(`${g.x},${g.y}`)
        }
      })

      window.addEventListener('pointerup', () => {
        if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          if (
            checkCollision(
              draggingComp.gx,
              draggingComp.gy,
              draggingComp.type,
              draggingComp.id
            )
          ) {
            draggingComp.gx = initialPos.gx
            draggingComp.gy = initialPos.gy
          }
        }
        if (mode === 'DRAGGING_WIRE') {
          if (!checkCollision(mouseGrid.x, mouseGrid.y, 'WIRE')) {
            wires.set(`${mouseGrid.x},${mouseGrid.y}`, true)
          } else {
            wires.set(draggingWire, true)
          }
        }
        if (mode !== 'DRAGGING_NEW') mode = 'IDLE'
        draggingComp = null
        draggingWire = null
      })

      window.addEventListener('contextmenu', (e) => e.preventDefault())
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
      })
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      initHUD()
      function loop() {
        render()
        requestAnimationFrame(loop)
      }
      loop()
    </script>
  </body>
</html>
