<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OpenCircuit</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

      code Code download content_copy expand_less * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        color-scheme: dark;
        user-select: none;
        font-family: 'JetBrains Mono', monospace;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background-color: #0f0f0f;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        z-index: 1;
      }

      .hud {
        position: absolute;
        top: 15px;
        left: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px;
        border: 1px solid #333;
        border-radius: 6px;
        background: rgba(15, 15, 15, 0.9);
        backdrop-filter: blur(8px);
        width: 160px;
        z-index: 10;
        max-height: calc(100vh - 30px);
        overflow-y: auto;
      }

      .hud::-webkit-scrollbar {
        width: 4px;
      }
      .hud::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }
      .hud::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 2px;
      }

      button {
        padding: 10px;
        background: #000;
        border: 1px solid #333;
        border-radius: 4px;
        color: #ccc;
        cursor: pointer;
        font-size: 12px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.1s;
        flex-shrink: 0;
        outline: none;
      }

      button:hover {
        background: #252525;
        border-color: #444;
        color: #fff;
      }
      button:active {
        background: #333;
      }
      button.danger {
        border-color: #522;
        color: #e55;
      }
      button.danger:hover {
        background: #311;
      }

      button.action {
        background: #112;
        border-color: #335;
        color: #aaf;
        justify-content: center;
      }
      button.action:hover {
        background: #224;
      }

      button.active {
        background: #333;
        border-color: #666;
        color: #fff;
        box-shadow: inset 0 0 0 1px #555;
      }

      .separator {
        height: 1px;
        background: #333;
        margin: 4px 0;
        flex-shrink: 0;
      }

      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="hud" id="hud"></div>

    code Code download content_copy expand_less
    <script>
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d', { alpha: false })
      const hud = document.getElementById('hud')

      const GRID_SIZE = 25

      const TOOLS = {
        WIRE: { label: 'WIRE', color: '#888', w: 1, h: 1, ins: 0, outs: 0 },
        INPUT: { label: 'IN', color: '#3b82f6', w: 2, h: 2, ins: 0, outs: 1 },
        OUTPUT: { label: 'OUT', color: '#22c55e', w: 2, h: 2, ins: 1, outs: 0 },
        NOT: { label: 'NOT', color: '#ef4444', w: 2, h: 2, ins: 1, outs: 1 },
        AND: { label: 'AND', color: '#eab308', w: 2, h: 2, ins: 2, outs: 1 },
        NAND: { label: 'NAND', color: '#14b8a6', w: 2, h: 2, ins: 2, outs: 1 },
        OR: { label: 'OR', color: '#a855f7', w: 2, h: 2, ins: 2, outs: 1 },
        NOR: { label: 'NOR', color: '#f97316', w: 2, h: 2, ins: 2, outs: 1 },
        XOR: { label: 'XOR', color: '#ec4899', w: 2, h: 2, ins: 2, outs: 1 },
        XNOR: { label: 'XNOR', color: '#6366f1', w: 2, h: 2, ins: 2, outs: 1 },
      }

      let components = []
      let wires = new Map()
      let wireStates = new Map()
      let customDefs = {}

      let camera = { x: 0, y: 0 }
      let mode = 'IDLE'
      let dragStart = { x: 0, y: 0 }
      let newCompType = null
      let draggingComp = null
      let draggingWire = null
      let dragOffset = { x: 0, y: 0 }
      let initialPos = { x: 0, y: 0 }
      let mouseGrid = { x: 0, y: 0 }

      let selectionStart = null
      let selectionEnd = null
      let selectedComponents = []

      class Component {
        constructor(gx, gy, type) {
          this.gx = gx
          this.gy = gy
          this.type = type
          this.id = Math.random().toString(36).substr(2, 9)
          this.state = false
          this.isLit = false

          if (customDefs[type]) {
            this.subCircuit = this.createSubCircuit(customDefs[type])
          }
        }

        createSubCircuit(def) {
          const subComponents = def.components.map((c) => {
            const copy = new Component(c.gx, c.gy, c.type)
            return copy
          })
          const subWires = new Map(def.wires)
          return {
            components: subComponents,
            wires: subWires,
            wireStates: new Map(),
          }
        }
      }

      function getWireState(map, gx, gy) {
        return map.get(`${gx},${gy}`) || false
      }

      function runSimulation(comps, wMap, wStates) {
        let nextGateStates = new Map()

        comps.forEach((c) => {
          const def = TOOLS[c.type]
          if (customDefs[c.type]) {
            const sub = c.subCircuit
            const subDef = customDefs[c.type]
            subDef.inputNodes.forEach((node, idx) => {
              const extVal = getWireState(wStates, c.gx - 1, c.gy + idx * 2)
              const intComp = sub.components[node.internalIndex]
              if (intComp) intComp.state = extVal
            })

            runSimulation(sub.components, sub.wires, sub.wireStates)

            subDef.outputNodes.forEach((node, idx) => {
              const intComp = sub.components[node.internalIndex]
              if (intComp && intComp.isLit) {
                nextGateStates.set(`${c.gx + def.w},${c.gy + idx * 2}`, true)
              }
            })
          } else if (c.type === 'OUTPUT') {
            c.isLit = getWireState(wStates, c.gx - 1, c.gy)
          } else if (c.type !== 'WIRE' && c.type !== 'INPUT') {
            const in1 = getWireState(wStates, c.gx - 1, c.gy)
            const in2 = getWireState(wStates, c.gx - 1, c.gy + 1)
            let active = false
            if (c.type === 'NOT') active = !in1
            if (c.type === 'AND') active = in1 && in2
            if (c.type === 'NAND') active = !(in1 && in2)
            if (c.type === 'OR') active = in1 || in2
            if (c.type === 'NOR') active = !(in1 || in2)
            if (c.type === 'XOR') active = !!in1 !== !!in2
            if (c.type === 'XNOR') active = !!in1 === !!in2

            if (active) {
              nextGateStates.set(`${c.gx + def.w},${c.gy}`, true)
            }
          }
        })

        let currentWireState = new Map()
        let queue = []
        let visited = new Set()

        comps.forEach((c) => {
          const def = TOOLS[c.type]
          if (c.type === 'INPUT' && c.state) {
            const key = `${c.gx + def.w},${c.gy}`
            if (!currentWireState.has(key)) {
              currentWireState.set(key, true)
              queue.push({ x: c.gx + def.w, y: c.gy })
            }
          }
        })

        nextGateStates.forEach((val, key) => {
          if (val && !currentWireState.has(key)) {
            currentWireState.set(key, true)
            const [gx, gy] = key.split(',').map(Number)
            queue.push({ x: gx, y: gy })
          }
        })

        while (queue.length > 0) {
          const curr = queue.shift()
          const key = `${curr.x},${curr.y}`
          if (visited.has(key)) continue
          visited.add(key)

          const neighbors = [
            { x: curr.x + 1, y: curr.y },
            { x: curr.x - 1, y: curr.y },
            { x: curr.x, y: curr.y + 1 },
            { x: curr.x, y: curr.y - 1 },
          ]

          neighbors.forEach((n) => {
            const nKey = `${n.x},${n.y}`
            if (checkConnectivity(n.x, n.y, comps, wMap)) {
              if (!currentWireState.has(nKey)) {
                currentWireState.set(nKey, true)
                queue.push(n)
              }
            }
          })
        }

        wStates.clear()
        currentWireState.forEach((v, k) => wStates.set(k, v))
      }

      function checkConnectivity(gx, gy, comps, wMap) {
        if (wMap.has(`${gx},${gy}`)) return true
        return comps.some((c) => {
          const def = TOOLS[c.type]
          if (customDefs[c.type]) {
            if (gx === c.gx - 1) {
              const dy = gy - c.gy
              if (dy >= 0 && dy < def.ins * 2 && dy % 2 === 0) return true
            }
            if (gx === c.gx + def.w) {
              const dy = gy - c.gy
              if (dy >= 0 && dy < def.outs * 2 && dy % 2 === 0) return true
            }
            return false
          }
          if (def.ins >= 1 && gx === c.gx - 1 && gy === c.gy) return true
          if (def.ins >= 2 && gx === c.gx - 1 && gy === c.gy + 1) return true
          if (def.outs >= 1 && gx === c.gx + def.w && gy === c.gy) return true
          return false
        })
      }

      function simulate() {
        runSimulation(components, wires, wireStates)
      }

      function shouldConnect(x1, y1, x2, y2) {
        const hasWire1 = wires.has(`${x1},${y1}`)
        const hasWire2 = wires.has(`${x2},${y2}`)
        if (x1 === x2 && y1 === y2) return true
        if (!hasWire1 && !hasWire2) return false

        return (
          checkConnectivity(x1, y1, components, wires) &&
          checkConnectivity(x2, y2, components, wires)
        )
      }

      function checkCollision(gx, gy, type, excludeId = null) {
        const def = TOOLS[type]
        const w = def.w
        const h = def.h
        const bodyCollision = components.some((c) => {
          if (c.id === excludeId) return false
          const cDef = TOOLS[c.type]
          return (
            gx < c.gx + cDef.w &&
            gx + w > c.gx &&
            gy < c.gy + cDef.h &&
            gy + h > c.gy
          )
        })
        return bodyCollision
      }

      function createCustomComponent() {
        if (!selectedComponents.length) {
          alert("Select components first using 'Select Area'")
          return
        }

        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity

        selectedComponents.forEach((c) => {
          const def = TOOLS[c.type]
          minX = Math.min(minX, c.gx)
          minY = Math.min(minY, c.gy)
          maxX = Math.max(maxX, c.gx + def.w)
          maxY = Math.max(maxY, c.gy + def.h)
        })

        let selectedWires = new Map()

        if (selectionStart && selectionEnd) {
          const sx = Math.min(selectionStart.x, selectionEnd.x)
          const ex = Math.max(selectionStart.x, selectionEnd.x)
          const sy = Math.min(selectionStart.y, selectionEnd.y)
          const ey = Math.max(selectionStart.y, selectionEnd.y)

          wires.forEach((_, key) => {
            const [wx, wy] = key.split(',').map(Number)
            if (wx >= sx && wx <= ex && wy >= sy && wy <= ey) {
              selectedWires.set(`${wx - minX},${wy - minY}`, true)
            }
          })
        }

        let normalizedComps = selectedComponents.map((c) => {
          return {
            type: c.type,
            gx: c.gx - minX,
            gy: c.gy - minY,
          }
        })

        let inputs = normalizedComps
          .filter((c) => c.type === 'INPUT')
          .sort((a, b) => a.gy - b.gy)
        let outputs = normalizedComps
          .filter((c) => c.type === 'OUTPUT')
          .sort((a, b) => a.gy - b.gy)

        const inputNodes = inputs.map((c) => ({
          internalIndex: normalizedComps.indexOf(c),
        }))
        const outputNodes = outputs.map((c) => ({
          internalIndex: normalizedComps.indexOf(c),
        }))

        const name = prompt(
          'Component Name:',
          'CHIP' + Object.keys(customDefs).length
        )
        if (!name) return

        const hue = Math.floor(Math.random() * 360)
        const color = `hsl(${hue}, 70%, 60%)`
        const compW = 4
        const compH = Math.max(2, inputs.length * 2, outputs.length * 2)

        customDefs[name] = {
          components: normalizedComps,
          wires: selectedWires,
          inputNodes: inputNodes,
          outputNodes: outputNodes,
        }

        TOOLS[name] = {
          label: name,
          color: color,
          w: compW,
          h: compH,
          ins: inputs.length,
          outs: outputs.length,
        }

        mode = 'IDLE'
        selectedComponents = []
        selectionStart = null
        selectionEnd = null
        refreshHUD()
      }

      function drawGrid() {
        ctx.strokeStyle = '#1a1a1a'
        ctx.lineWidth = 1
        ctx.beginPath()
        const offX = camera.x % GRID_SIZE
        const offY = camera.y % GRID_SIZE
        for (let x = offX; x < canvas.width; x += GRID_SIZE) {
          ctx.moveTo(x + 0.5, 0)
          ctx.lineTo(x + 0.5, canvas.height)
        }
        for (let y = offY; y < canvas.height; y += GRID_SIZE) {
          ctx.moveTo(0, y + 0.5)
          ctx.lineTo(canvas.width, y + 0.5)
        }
        ctx.stroke()
      }

      function drawWireSegment(gx, gy, isPowered, activeColor, activeWidth) {
        const px = gx * GRID_SIZE + camera.x + GRID_SIZE / 2
        const py = gy * GRID_SIZE + camera.y + GRID_SIZE / 2

        ctx.strokeStyle = isPowered ? activeColor : '#555'
        ctx.lineWidth = isPowered ? activeWidth : 2
        ctx.shadowBlur = isPowered ? 8 : 0
        ctx.shadowColor = '#ffffaa'

        const u = shouldConnect(gx, gy, gx, gy - 1)
        const d = shouldConnect(gx, gy, gx, gy + 1)
        const l = shouldConnect(gx, gy, gx - 1, gy)
        const r = shouldConnect(gx, gy, gx + 1, gy)

        ctx.beginPath()
        if (u) {
          ctx.moveTo(px, py)
          ctx.lineTo(px, py - GRID_SIZE / 2)
        }
        if (d) {
          ctx.moveTo(px, py)
          ctx.lineTo(px, py + GRID_SIZE / 2)
        }
        if (l) {
          ctx.moveTo(px, py)
          ctx.lineTo(px - GRID_SIZE / 2, py)
        }
        if (r) {
          ctx.moveTo(px, py)
          ctx.lineTo(px + GRID_SIZE / 2, py)
        }

        if (!u && !d && !l && !r) {
          ctx.moveTo(px - 4, py)
          ctx.lineTo(px + 4, py)
        }
        ctx.stroke()

        const neighbors = (u ? 1 : 0) + (d ? 1 : 0) + (l ? 1 : 0) + (r ? 1 : 0)
        const isStraight = (u && d && !l && !r) || (l && r && !u && !d)

        if (
          neighbors > 2 ||
          (neighbors === 2 && !isStraight) ||
          neighbors === 1
        ) {
          ctx.fillStyle = isPowered ? activeColor : '#555'
          ctx.beginPath()
          ctx.arc(px, py, isPowered ? 4 : 3, 0, Math.PI * 2)
          ctx.fill()
        }
        ctx.shadowBlur = 0
      }

      function drawWires() {
        ctx.lineCap = 'round'
        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`
        const activeWidth = 2 + pulse * 1.5

        wires.forEach((_, key) => {
          const [gx, gy] = key.split(',').map(Number)
          drawWireSegment(gx, gy, wireStates.get(key), activeColor, activeWidth)
        })
      }

      function drawComponent(c, isGhost = false) {
        if (c.type === 'WIRE') {
          drawWireSegment(c.gx, c.gy, false, '#fff', 2)
          return
        }

        const def = TOOLS[c.type]
        const x = c.gx * GRID_SIZE + camera.x
        const y = c.gy * GRID_SIZE + camera.y
        const w = def.w * GRID_SIZE
        const h = def.h * GRID_SIZE

        if (isGhost) ctx.globalAlpha = 0.6
        if (isGhost && checkCollision(c.gx, c.gy, c.type))
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'
        else if (selectedComponents.includes(c)) ctx.fillStyle = '#445'
        else ctx.fillStyle = '#000'

        ctx.save()

        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`
        const activeWidth = 2 + pulse * 1.5

        const drawPin = (pgx, pgy) => {
          const isPowered = wireStates.get(`${pgx},${pgy}`)
          drawWireSegment(pgx, pgy, isPowered, activeColor, activeWidth)
        }

        if (customDefs[c.type]) {
          for (let i = 0; i < def.ins; i++) drawPin(c.gx - 1, c.gy + i * 2)
          for (let i = 0; i < def.outs; i++) drawPin(c.gx + def.w, c.gy + i * 2)
        } else {
          if (def.ins >= 1) drawPin(c.gx - 1, c.gy)
          if (def.ins >= 2) drawPin(c.gx - 1, c.gy + 1)
          if (def.outs >= 1) drawPin(c.gx + def.w, c.gy)
        }

        ctx.restore()

        ctx.fillRect(x, y, w, h)
        ctx.strokeStyle = def.color
        ctx.lineWidth = 2
        ctx.strokeRect(x, y, w, h)

        ctx.fillStyle = def.color
        ctx.font = 'bold 12px "JetBrains Mono"'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        if (c.type === 'INPUT') {
          const pad = 8
          ctx.fillStyle = '#000'
          ctx.fillRect(x + pad, y + pad, w - pad * 2, h - pad * 2)
          if (c.state) {
            ctx.fillStyle = '#4f4'
            ctx.fillRect(
              x + pad + 2,
              y + pad + 2,
              w - pad * 2 - 4,
              h - pad * 2 - 4
            )
            ctx.fillStyle = '#fff'
            ctx.fillText('ON', x + w / 2, y + h / 2)
          } else {
            ctx.fillStyle = '#333'
            ctx.fillText('OFF', x + w / 2, y + h / 2)
          }
        } else if (c.type === 'OUTPUT') {
          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 12, 0, Math.PI * 2)
          ctx.fillStyle = '#000'
          ctx.fill()
          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 8, 0, Math.PI * 2)
          if (c.isLit) {
            ctx.fillStyle = '#ffff00'
            ctx.shadowColor = '#ffff00'
            ctx.shadowBlur = 20
          } else {
            ctx.fillStyle = '#333'
          }
          ctx.fill()
          ctx.shadowBlur = 0
        } else {
          ctx.fillText(def.label, x + w / 2, y + h / 2)
        }

        if (isGhost) ctx.globalAlpha = 1.0
      }

      function render() {
        simulate()
        ctx.fillStyle = '#0f0f0f'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        drawGrid()
        drawWires()
        for (const c of components) drawComponent(c)
        if (mode === 'DRAGGING_NEW' && newCompType) {
          drawComponent(
            { gx: mouseGrid.x, gy: mouseGrid.y, type: newCompType },
            true
          )
        }

        if (mode === 'SELECTING' && selectionStart) {
          const mx = mouseGrid.x * GRID_SIZE + camera.x
          const my = mouseGrid.y * GRID_SIZE + camera.y
          const sx = selectionStart.x * GRID_SIZE + camera.x
          const sy = selectionStart.y * GRID_SIZE + camera.y

          ctx.strokeStyle = '#fff'
          ctx.lineWidth = 1
          ctx.setLineDash([5, 5])
          ctx.strokeRect(sx, sy, mx - sx, my - sy)
          ctx.setLineDash([])

          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'
          ctx.fillRect(sx, sy, mx - sx, my - sy)
        }
      }

      function getGrid(clientPos) {
        return {
          x: Math.floor((clientPos.x - camera.x) / GRID_SIZE),
          y: Math.floor((clientPos.y - camera.y) / GRID_SIZE),
        }
      }

      function refreshHUD() {
        hud.innerHTML = ''

        const selectBtn = document.createElement('button')
        selectBtn.className = mode === 'SELECTING' ? 'action active' : 'action'
        selectBtn.innerText = '[ ] Select Area'
        selectBtn.onclick = () => {
          mode = mode === 'SELECTING' ? 'IDLE' : 'SELECTING'
          selectedComponents = []
          selectionStart = null
          refreshHUD()
        }
        hud.appendChild(selectBtn)

        const createBtn = document.createElement('button')
        createBtn.className = 'action'
        createBtn.innerText = '+ Save Comp'
        createBtn.onclick = createCustomComponent
        hud.appendChild(createBtn)

        const sep = document.createElement('div')
        sep.className = 'separator'
        hud.appendChild(sep)

        Object.keys(TOOLS).forEach((key) => {
          const def = TOOLS[key]
          const btn = document.createElement('button')
          const swatch = document.createElement('span')
          swatch.className = 'swatch'
          swatch.style.backgroundColor = def.color
          btn.appendChild(swatch)
          btn.appendChild(document.createTextNode(def.label))

          btn.onpointerdown = (e) => {
            e.preventDefault()
            e.stopPropagation()
            btn.setPointerCapture(e.pointerId)
            mode = 'DRAGGING_NEW'
            newCompType = key
            mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
          }

          btn.onpointerup = (e) => {
            btn.releasePointerCapture(e.pointerId)
            if (mode === 'DRAGGING_NEW') {
              const g = getGrid({ x: e.clientX, y: e.clientY })
              if (newCompType === 'WIRE') {
                if (!checkCollision(g.x, g.y, 'WIRE'))
                  wires.set(`${g.x},${g.y}`, true)
              } else {
                if (!checkCollision(g.x, g.y, newCompType)) {
                  components.push(new Component(g.x, g.y, newCompType))
                }
              }
            }
            mode = 'IDLE'
            newCompType = null
          }
          hud.appendChild(btn)
        })

        const sep2 = document.createElement('div')
        sep2.className = 'separator'
        hud.appendChild(sep2)

        const clearBtn = document.createElement('button')
        clearBtn.className = 'danger'
        clearBtn.innerText = 'Clear All'
        clearBtn.onclick = () => {
          if (confirm('Reset Board?')) {
            components = []
            wires.clear()
            wireStates.clear()
            selectedComponents = []
            camera = { x: 0, y: 0 }
          }
        }
        hud.appendChild(clearBtn)
      }

      canvas.addEventListener('pointerdown', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })

        if (mode === 'SELECTING') {
          selectionStart = g
          return
        }

        if (e.button === 2) {
          const hit = components.find(
            (c) =>
              g.x >= c.gx &&
              g.x < c.gx + TOOLS[c.type].w &&
              g.y >= c.gy &&
              g.y < c.gy + TOOLS[c.type].h
          )
          if (hit) {
            components.splice(components.indexOf(hit), 1)
            const idx = selectedComponents.indexOf(hit)
            if (idx > -1) selectedComponents.splice(idx, 1)
          } else {
            wires.delete(`${g.x},${g.y}`)
            mode = 'ERASING'
          }
          return
        }

        const hit = components.find(
          (c) =>
            g.x >= c.gx &&
            g.x < c.gx + TOOLS[c.type].w &&
            g.y >= c.gy &&
            g.y < c.gy + TOOLS[c.type].h
        )

        if (hit) {
          if (hit.type === 'INPUT') {
            const screenX = hit.gx * GRID_SIZE + camera.x
            const screenY = hit.gy * GRID_SIZE + camera.y
            const cx = e.clientX - screenX
            const cy = e.clientY - screenY
            const pad = 8
            const w = TOOLS[hit.type].w * GRID_SIZE
            const h = TOOLS[hit.type].h * GRID_SIZE
            if (cx > pad && cx < w - pad && cy > pad && cy < h - pad) {
              hit.state = !hit.state
              return
            }
          }
          mode = 'DRAGGING_EXISTING'
          draggingComp = hit
          initialPos = { gx: hit.gx, gy: hit.gy }
          dragOffset = { x: g.x - hit.gx, y: g.y - hit.gy }
        } else if (wires.has(`${g.x},${g.y}`)) {
          mode = 'DRAGGING_WIRE'
          draggingWire = `${g.x},${g.y}`
          wires.delete(draggingWire)
        } else {
          mode = 'PANNING'
          dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
        }
      })

      window.addEventListener('pointermove', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })
        mouseGrid = g
        if (mode === 'PANNING') {
          camera.x = e.clientX - dragStart.x
          camera.y = e.clientY - dragStart.y
        } else if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          draggingComp.gx = g.x - dragOffset.x
          draggingComp.gy = g.y - dragOffset.y
        } else if (mode === 'ERASING') {
          wires.delete(`${g.x},${g.y}`)
        } else if (mode === 'SELECTING' && selectionStart) {
          selectionEnd = g
        }
      })

      window.addEventListener('pointerup', (e) => {
        if (mode === 'SELECTING' && selectionStart) {
          selectionEnd = getGrid({ x: e.clientX, y: e.clientY })
          const sx = Math.min(selectionStart.x, selectionEnd.x)
          const ex = Math.max(selectionStart.x, selectionEnd.x)
          const sy = Math.min(selectionStart.y, selectionEnd.y)
          const ey = Math.max(selectionStart.y, selectionEnd.y)

          selectedComponents = components.filter((c) => {
            const def = TOOLS[c.type]
            return (
              c.gx >= sx &&
              c.gx + def.w <= ex + 1 &&
              c.gy >= sy &&
              c.gy + def.h <= ey + 1
            )
          })
          mode = 'IDLE'
        } else if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          if (
            checkCollision(
              draggingComp.gx,
              draggingComp.gy,
              draggingComp.type,
              draggingComp.id
            )
          ) {
            draggingComp.gx = initialPos.gx
            draggingComp.gy = initialPos.gy
          }
        } else if (mode === 'DRAGGING_WIRE') {
          if (!checkCollision(mouseGrid.x, mouseGrid.y, 'WIRE')) {
            wires.set(`${mouseGrid.x},${mouseGrid.y}`, true)
          } else {
            wires.set(draggingWire, true)
          }
        }

        if (mode !== 'DRAGGING_NEW' && mode !== 'SELECTING') mode = 'IDLE'
        draggingComp = null
        draggingWire = null
        selectionStart = null
      })

      window.addEventListener('contextmenu', (e) => e.preventDefault())
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
      })
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      refreshHUD()
      function loop() {
        render()
        requestAnimationFrame(loop)
      }
      loop()
    </script>
  </body>
</html>
